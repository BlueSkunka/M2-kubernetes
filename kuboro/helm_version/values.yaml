# Default values for orocommerce.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# This will set the replicaset count more information can be found here: https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/
replicaCount: 1

namespace: orocommerce

storageClass:
  name: local-storage
  provisioner: kubernetes.io/no-provisioner
  volumeBindingMode: WaitForFirstConsumer
  reclaimPolicy: Retain

images:
  oroImage: oroinc/orocommerce-application
  oroImageTag: 6.1.0
  oroImageInit: oroinc/orocommerce-application-init-fr
  oroImageInitTag: 6.1.0
  oroImageBaseRuntime: oroinc/runtime
  oroImageBaseRuntimeTag: 6.1-latest

appSecurityContext:
  runAsUser: 2002
  runAsGroup: 2001

rootSecurityContext:
  runAsUser: 0

envLogValue: php://stderr
persistentVolumes:
  ## Utiliser pour le node affinity du pv
  nodeHostname: minikube
  ## PV de l'application
  appCapacity: 10Gi
  appAccessModes:
    - ReadWriteMany
    - ReadOnlyMany
  appHostPath: /orocommerce/app
  ## PV du cache de l'application
  appCacheCapacity: 10Gi
  appCacheAccessModes:
    - ReadWriteMany
    - ReadOnlyMany
  appCacheHostPath: /orocommerce/cache
  ## PV de la maintenance de l'application

  appMaintenanceCapacity: 10Gi
  appMaintenanceAccessModes:
    - ReadWriteMany
    - ReadOnlyMany
  appMaintenanceHostPath: /orocommerce/maintenance
  ## PV des opération multiples de l'application
  appMultihostOperationCapacity: 10Gi
  appMultihostOperationAccessModes:
    - ReadWriteMany
    - ReadOnlyMany
  appMultihostOperationHostPath: /orocommerce/multihost-operation
  ## PV des dossiers privés de l'application
  appPrivateCapacity: 10Gi
  appPrivateAccessModes:
    - ReadWriteMany
    - ReadOnlyMany
  appPrivateHostPath: /orocommerce/private
  ## PV des dossiers publics de l'application
  appPublicCapacity: 10Gi
  appPublicAccessModes:
    - ReadWriteMany
    - ReadOnlyMany
  appPublicHostPath: /orocommerce/public
  ## PV du NGNIX
  nginxCapacity: 10Gi
  nginxAccessModes:
    - ReadWriteMany
  nginxHostPath: /orocommerce/nginx
  ## PV Postgre
  postgreCapacity: 10Gi
  postgreAccessModes:
    - ReadWriteOncePod
  postgreHostPath: /orocommerce/postgre


  
restore:
  initContainerName: volume-init
  initContainerArgs: 
    - -c
    - "cp -rp /var/www/oro/. /data && chown -R www-data:www-data /data"
  defaultContainerName: restore
  defaultContainerCommand: 
    - sh
    - -c 
    - "until nc -z orocommerce-postgre 5432; do echo \"Waiting for database connection...\"; sleep 1; done && docker-entrypoint.sh restore"
  restartPolicy: Never

consumer:
  initContainerName: verify-connection
  initContainerCommand: 
    - "sh"
    - "-c"
    - "until nc -z orocommerce-app 9000; do echo \"Waiting for php-fpm connection...\"; sleep 1; done"
  defaultContainerName: consumer
  defaultContainerArgs: 
    - "consumer"

cron:
  initContainerName: verify-connection
  initContainerCommand: 
    - "sh"
    - "-c"
    - "until nc -z orocommerce-app 9000; do echo \"Waiting for php-fpm connection...\"; sleep 1; done"
  defaultContainerName: cron
  defaultContainerArgs: 
    - "cron"

app:
  defaultContainerName: orocommerce-app
  defaultContainerArgs: ["php-fpm"]
  defaultContainerPorts:
    - containerPort: 9000
  defaultLivenessProbe:
    exec:
      command:
          - /bin/sh
          - -c
          - php-fpm-healthcheck
    periodSeconds: 5
    initialDelaySeconds: 15
    timeoutSeconds: 30
  defaultContainerResource:
    requests:
      memory: "200Mi"
      cpu: "200m"
    # limits:
    #   memory: "300Mi"
    #   cpu: "300m"
  hpaMinReplicas: 1
  hpaMaxReplicas: 2
  hpaAverageCpuUtilization: 20

nginx:
  initContainerName: ngnix-init
  initContainerCommand: ["sh", "-c", "until nc -z orocommerce-app 9000; do echo \"Waiting for php-fpm connection...\"; sleep 1; done && until nc -z orocommerce-websocket 8080; do echo \"Waiting for php-fpm connection...\"; sleep 1; done && /usr/local/bin/docker-entrypoint.sh nginx-init && sed -i '/gridfs/d; /mongo/d' /opt/oro-nginx/etc/sites-available/*.conf"]
  defaultContainerName: nginx
  defaultContainerArgs: ["nginx"]
  defaultContainerPorts:
    - containerPort: 80
  livenessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 15
          periodSeconds: 5
          timeoutSeconds: 30
  startupProbe:
    httpGet:
      path: /
      port: 80
    initialDelaySeconds: 15
    periodSeconds: 5
    timeoutSeconds: 30

ingressHost: oro.demo

websocket:
  initContainerName: ngnix-init
  initContainerCommand: ["sh", "-c", "until nc -z orocommerce-app 9000; do echo \"Waiting for php-fpm connection...\"; sleep 1; done"]
  defaultContainerName: websocket
  defaultContainerArgs: ["websocket"]
  defaultContainerPorts:
    - containerPort: 8080


# This sets the container image more information can be found here: https://kubernetes.io/docs/concepts/containers/images/
image:
  repository: nginx
  # This sets the pull policy for images.
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""

# This is for the secrets for pulling an image from a private repository more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
imagePullSecrets: []
# This is to override the chart name.
nameOverride: ""
fullnameOverride: ""

# This section builds out the service account more information can be found here: https://kubernetes.io/docs/concepts/security/service-accounts/
serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Automatically mount a ServiceAccount's API credentials?
  automount: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

# This is for setting Kubernetes Annotations to a Pod.
# For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
podAnnotations: {}
# This is for setting Kubernetes Labels to a Pod.
# For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
podLabels: {}

podSecurityContext: {}
  # fsGroup: 2000

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

# This is for setting up a service more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/
service:
  # This sets the service type more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
  type: ClusterIP
  # This sets the ports more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#field-spec-ports
  port: 80

# This block is for setting up the ingress for more information can be found here: https://kubernetes.io/docs/concepts/services-networking/ingress/
ingress:
  enabled: false
  className: ""
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: chart-example.local
      paths:
        - path: /
          pathType: ImplementationSpecific
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

# This is to setup the liveness and readiness probes more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
livenessProbe:
  httpGet:
    path: /
    port: http
readinessProbe:
  httpGet:
    path: /
    port: http

# This section is for setting up autoscaling more information can be found here: https://kubernetes.io/docs/concepts/workloads/autoscaling/
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

# Additional volumes on the output Deployment definition.
volumes: []
# - name: foo
#   secret:
#     secretName: mysecret
#     optional: false

# Additional volumeMounts on the output Deployment definition.
volumeMounts: []
# - name: foo
#   mountPath: "/etc/foo"
#   readOnly: true

nodeSelector: {}

tolerations: []

affinity: {}
